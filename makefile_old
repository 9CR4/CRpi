all: car #chiamato se non si specifica nulla


ifneq ($(shell uname -m),armv7l)
      $(error not on arm, you must use a raspberry)
endif

#Con le opzioni M gcc crea dei file di dipendenza che indicano le dipendenze dei file c dagli header
#MP aggiunge una phony per ogni header in modo che make non si lamenti di header che non esistono più
#MD dice di chiamare il file dipendenza come il .o ma con estensione .d, inoltre rende tutta la creazione
#	delle dipendenze un side-effect della compilazione (altrimenti avrebbe fatto solo quello)
COMPILER_OPTIONS	:= -MP -MD -std=gnu11
COMPILER := gcc

LINKER_OPTIONS :=
LINKER := gcc

FILES_SORGENTE_C	:= $(shell find ./src -type f -name "*.c") #finds files .c in src
FILES_HEADER_H	:= $(shell find ./src -type f -name "*.h") #finds files .h in src
FILES_OGGETTO_O	:= $(patsubst %.c,%.o,$(FILES_SORGENTE_C)) #for every .c file there's gonna be a .o file
FILES_DIPENDENZA_D:= $(patsubst %.c,%.d,$(FILES_SORGENTE_C)) #dependency files generated by gcc

.PHONY: all #perchè non si metta a cercare un file chiamato "all"

#includes the dependency files in this makefile, the - hides the errors (e.g. non existant files)
-include $(FILES_DIPENDENZA_D)

car: $(FILES_OGGETTO_O) #car depends ont he object files
	@echo "linking..."
	#@echo $(FILES_OGGETTO_O)
	@$(LINKER) -o car $(FILES_OGGETTO_O) $(LINKER_OPTIONS)
	#@echo "linked successfully"

%.o : %.c			#the .o files depend on the .c ones
	@echo "compiling '" $< "'"
	@$(COMPILER) -o "$@" -c "$<" $(COMPILER_OPTIONS)
	#@echo "compiled"

debug: COMPILER_OPTIONS+=-g
debug: car

clean:			#cleans the project
	-@$(RM) $(wildcard $(FILES_OGGETTO_O) $(FILES_DIPENDENZA_D) car)
